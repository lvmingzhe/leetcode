# 哈希表：Hash table

> 哈希表是根据关键码的值而直接进行访问的数据结构。

数组就是一种特殊的哈希表
- (key)关键码：数组的索引下标
- (value)值：通过下标访问数组中的元素

# 查询速度

哈希表可以用来快速判断一个元素是否出现在集合里，查询时间$O(1)$.

比如查询一个学生是否属于一个学校，将学生名字作为key，值value是是否在校。

# 哈希映射与碰撞

将学生名字映射到哈希表种的操作就涉及到了哈表函数(Hash funciton).

如果有两个学生的名字映射到表中同一个位置，则发生了哈希碰撞(Hash collisions).

解决哈希碰撞一般有两种方法：拉链法和线性探测法。

拉链法就是将冲突的元素以链表的形式存在起冲突的位置。

线性法就是保证hash table的尺寸要大于数据的尺寸,这样才能保证每一个数据都能单独存下。

# 常见哈希结构

- 数组
- set
- map

## set的三种

| 集合 | 底层实现 | 有序性 | 重复性 | 查询效率 | 增删效率 |
|-     |   -     | -      |  -    |   -      |   -      |
| std::set | 红黑树 | 有序 | 否 | O(logn) | O(logn) |
| std::multiset | 红黑树 | 有序 | 是 | O(logn) | O(logn) |
| std::unordered_set | 哈希表 | 无序 | 否 | O(1) | O(1) |

红黑树是一种平衡二叉搜索树，所以key值是有序的，而且key值不可以修改。改动key值会导致整棵树的错乱，所以只能删除和增加。

当我们需要用集合来解决哈希问题的时候，可以优先使用unordered_set。如果集合是有序的，就用set。如果要求有重复数据的话，就用multiset

## map的三种


| 集合 | 底层实现 | 有序性 | 重复性 | 查询效率 | 增删效率 |
|-     |   -     | -      |  -    |   -      |   -      |
| std::map | 红黑树 | key有序 | 否 | O(logn) | O(logn) |
| std::multimap | 红黑树 | key有序 | 是 | O(logn) | O(logn) |
| std::unordered_map | 哈希表 | key无序 | 否 | O(1) | O(1) |


> <font color="red">我的疑问：到底map和set是啥区别？啥时候用map好？啥时候用set好？</font>

# 总结

哈希法的本质是以空间换时间。
当我们遇到了要快速判断一个元素是否出现集合里的时候，就要考虑哈希法。